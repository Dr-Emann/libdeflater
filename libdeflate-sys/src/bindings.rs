/* automatically generated by rust-bindgen 0.71.1 */

pub const LIBDEFLATE_VERSION_MAJOR: u32 = 1;
pub const LIBDEFLATE_VERSION_MINOR: u32 = 23;
pub const LIBDEFLATE_VERSION_STRING: &[u8; 5] = b"1.23\0";
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libdeflate_compressor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libdeflate_decompressor {
    _unused: [u8; 0],
}
pub const libdeflate_result_LIBDEFLATE_SUCCESS: libdeflate_result = 0;
pub const libdeflate_result_LIBDEFLATE_BAD_DATA: libdeflate_result = 1;
pub const libdeflate_result_LIBDEFLATE_SHORT_OUTPUT: libdeflate_result = 2;
pub const libdeflate_result_LIBDEFLATE_INSUFFICIENT_SPACE: libdeflate_result = 3;
#[doc = " Result of a call to libdeflate_deflate_decompress(),\n libdeflate_zlib_decompress(), or libdeflate_gzip_decompress()."]
pub type libdeflate_result = ::core::ffi::c_uint;
#[doc = " Advanced options.  This is the options structure that\n libdeflate_alloc_compressor_ex() and libdeflate_alloc_decompressor_ex()\n require.  Most users won't need this and should just use the non-\"_ex\"\n functions instead.  If you do need this, it should be initialized like this:\n\n\tstruct libdeflate_options options;\n\n\tmemset(&options, 0, sizeof(options));\n\toptions.sizeof_options = sizeof(options);\n\t// Then set the fields that you need to override the defaults for."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct libdeflate_options {
    #[doc = " This field must be set to the struct size.  This field exists for\n extensibility, so that fields can be appended to this struct in\n future versions of libdeflate while still supporting old binaries."]
    pub sizeof_options: usize,
    #[doc = " An optional custom memory allocator to use for this (de)compressor.\n 'malloc_func' must be a function that behaves like malloc(), and\n 'free_func' must be a function that behaves like free().\n\n This is useful in cases where a process might have multiple users of\n libdeflate who want to use different memory allocators.  For example,\n a library might want to use libdeflate with a custom memory allocator\n without interfering with user code that might use libdeflate too.\n\n This takes priority over the \"global\" memory allocator (which by\n default is malloc() and free(), but can be changed by\n libdeflate_set_memory_allocator()).  Moreover, libdeflate will never\n call the \"global\" memory allocator if a per-(de)compressor custom\n allocator is always given."]
    pub malloc_func:
        ::core::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::core::ffi::c_void>,
    pub free_func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
}
extern "C" {
    #[doc = " libdeflate_alloc_compressor() allocates a new compressor that supports\n DEFLATE, zlib, and gzip compression.  'compression_level' is the compression\n level on a zlib-like scale but with a higher maximum value (1 = fastest, 6 =\n medium/default, 9 = slow, 12 = slowest).  Level 0 is also supported and means\n \"no compression\", specifically \"create a valid stream, but only emit\n uncompressed blocks\" (this will expand the data slightly).\n\n The return value is a pointer to the new compressor, or NULL if out of memory\n or if the compression level is invalid (i.e. outside the range [0, 12]).\n\n Note: for compression, the sliding window size is defined at compilation time\n to 32768, the largest size permissible in the DEFLATE format.  It cannot be\n changed at runtime.\n\n A single compressor is not safe to use by multiple threads concurrently.\n However, different threads may use different compressors concurrently."]
    pub fn libdeflate_alloc_compressor(
        compression_level: ::core::ffi::c_int,
    ) -> *mut libdeflate_compressor;
    #[doc = " Like libdeflate_alloc_compressor(), but adds the 'options' argument."]
    pub fn libdeflate_alloc_compressor_ex(
        compression_level: ::core::ffi::c_int,
        options: *const libdeflate_options,
    ) -> *mut libdeflate_compressor;
    #[doc = " libdeflate_deflate_compress() performs raw DEFLATE compression on a buffer of\n data.  It attempts to compress 'in_nbytes' bytes of data located at 'in' and\n write the result to 'out', which has space for 'out_nbytes_avail' bytes.  The\n return value is the compressed size in bytes, or 0 if the data could not be\n compressed to 'out_nbytes_avail' bytes or fewer.\n\n If compression is successful, then the output data is guaranteed to be a\n valid DEFLATE stream that decompresses to the input data.  No other\n guarantees are made about the output data.  Notably, different versions of\n libdeflate can produce different compressed data for the same uncompressed\n data, even at the same compression level.  Do ***NOT*** do things like\n writing tests that compare compressed data to a golden output, as this can\n break when libdeflate is updated.  (This property isn't specific to\n libdeflate; the same is true for zlib and other compression libraries too.)"]
    pub fn libdeflate_deflate_compress(
        compressor: *mut libdeflate_compressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
    ) -> usize;
    #[doc = " libdeflate_deflate_compress_bound() returns a worst-case upper bound on the\n number of bytes of compressed data that may be produced by compressing any\n buffer of length less than or equal to 'in_nbytes' using\n libdeflate_deflate_compress() with the specified compressor.  This bound will\n necessarily be a number greater than or equal to 'in_nbytes'.  It may be an\n overestimate of the true upper bound.  The return value is guaranteed to be\n the same for all invocations with the same compressor and same 'in_nbytes'.\n\n As a special case, 'compressor' may be NULL.  This causes the bound to be\n taken across *any* libdeflate_compressor that could ever be allocated with\n this build of the library, with any options.\n\n Note that this function is not necessary in many applications.  With\n block-based compression, it is usually preferable to separately store the\n uncompressed size of each block and to store any blocks that did not compress\n to less than their original size uncompressed.  In that scenario, there is no\n need to know the worst-case compressed size, since the maximum number of\n bytes of compressed data that may be used would always be one less than the\n input length.  You can just pass a buffer of that size to\n libdeflate_deflate_compress() and store the data uncompressed if\n libdeflate_deflate_compress() returns 0, indicating that the compressed data\n did not fit into the provided output buffer."]
    pub fn libdeflate_deflate_compress_bound(
        compressor: *mut libdeflate_compressor,
        in_nbytes: usize,
    ) -> usize;
    #[doc = " Like libdeflate_deflate_compress(), but uses the zlib wrapper format instead\n of raw DEFLATE."]
    pub fn libdeflate_zlib_compress(
        compressor: *mut libdeflate_compressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
    ) -> usize;
    #[doc = " Like libdeflate_deflate_compress_bound(), but assumes the data will be\n compressed with libdeflate_zlib_compress() rather than with\n libdeflate_deflate_compress()."]
    pub fn libdeflate_zlib_compress_bound(
        compressor: *mut libdeflate_compressor,
        in_nbytes: usize,
    ) -> usize;
    #[doc = " Like libdeflate_deflate_compress(), but uses the gzip wrapper format instead\n of raw DEFLATE."]
    pub fn libdeflate_gzip_compress(
        compressor: *mut libdeflate_compressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
    ) -> usize;
    #[doc = " Like libdeflate_deflate_compress_bound(), but assumes the data will be\n compressed with libdeflate_gzip_compress() rather than with\n libdeflate_deflate_compress()."]
    pub fn libdeflate_gzip_compress_bound(
        compressor: *mut libdeflate_compressor,
        in_nbytes: usize,
    ) -> usize;
    #[doc = " libdeflate_free_compressor() frees a compressor that was allocated with\n libdeflate_alloc_compressor().  If a NULL pointer is passed in, no action is\n taken."]
    pub fn libdeflate_free_compressor(compressor: *mut libdeflate_compressor);
    #[doc = " libdeflate_alloc_decompressor() allocates a new decompressor that can be used\n for DEFLATE, zlib, and gzip decompression.  The return value is a pointer to\n the new decompressor, or NULL if out of memory.\n\n This function takes no parameters, and the returned decompressor is valid for\n decompressing data that was compressed at any compression level and with any\n sliding window size.\n\n A single decompressor is not safe to use by multiple threads concurrently.\n However, different threads may use different decompressors concurrently."]
    pub fn libdeflate_alloc_decompressor() -> *mut libdeflate_decompressor;
    #[doc = " Like libdeflate_alloc_decompressor(), but adds the 'options' argument."]
    pub fn libdeflate_alloc_decompressor_ex(
        options: *const libdeflate_options,
    ) -> *mut libdeflate_decompressor;
    #[doc = " libdeflate_deflate_decompress() decompresses a DEFLATE stream from the buffer\n 'in' with compressed size up to 'in_nbytes' bytes.  The uncompressed data is\n written to 'out', a buffer with size 'out_nbytes_avail' bytes.  If\n decompression succeeds, then 0 (LIBDEFLATE_SUCCESS) is returned.  Otherwise,\n a nonzero result code such as LIBDEFLATE_BAD_DATA is returned, and the\n contents of the output buffer are undefined.\n\n Decompression stops at the end of the DEFLATE stream (as indicated by the\n BFINAL flag), even if it is actually shorter than 'in_nbytes' bytes.\n\n libdeflate_deflate_decompress() can be used in cases where the actual\n uncompressed size is known (recommended) or unknown (not recommended):\n\n   - If the actual uncompressed size is known, then pass the actual\n     uncompressed size as 'out_nbytes_avail' and pass NULL for\n     'actual_out_nbytes_ret'.  This makes libdeflate_deflate_decompress() fail\n     with LIBDEFLATE_SHORT_OUTPUT if the data decompressed to fewer than the\n     specified number of bytes.\n\n   - If the actual uncompressed size is unknown, then provide a non-NULL\n     'actual_out_nbytes_ret' and provide a buffer with some size\n     'out_nbytes_avail' that you think is large enough to hold all the\n     uncompressed data.  In this case, if the data decompresses to less than\n     or equal to 'out_nbytes_avail' bytes, then\n     libdeflate_deflate_decompress() will write the actual uncompressed size\n     to *actual_out_nbytes_ret and return 0 (LIBDEFLATE_SUCCESS).  Otherwise,\n     it will return LIBDEFLATE_INSUFFICIENT_SPACE if the provided buffer was\n     not large enough but no other problems were encountered, or another\n     nonzero result code if decompression failed for another reason."]
    pub fn libdeflate_deflate_decompress(
        decompressor: *mut libdeflate_decompressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
        actual_out_nbytes_ret: *mut usize,
    ) -> libdeflate_result;
    #[doc = " Like libdeflate_deflate_decompress(), but adds the 'actual_in_nbytes_ret'\n argument.  If decompression succeeds and 'actual_in_nbytes_ret' is not NULL,\n then the actual compressed size of the DEFLATE stream (aligned to the next\n byte boundary) is written to *actual_in_nbytes_ret."]
    pub fn libdeflate_deflate_decompress_ex(
        decompressor: *mut libdeflate_decompressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
        actual_in_nbytes_ret: *mut usize,
        actual_out_nbytes_ret: *mut usize,
    ) -> libdeflate_result;
    #[doc = " Like libdeflate_deflate_decompress(), but assumes the zlib wrapper format\n instead of raw DEFLATE.\n\n Decompression will stop at the end of the zlib stream, even if it is shorter\n than 'in_nbytes'.  If you need to know exactly where the zlib stream ended,\n use libdeflate_zlib_decompress_ex()."]
    pub fn libdeflate_zlib_decompress(
        decompressor: *mut libdeflate_decompressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
        actual_out_nbytes_ret: *mut usize,
    ) -> libdeflate_result;
    #[doc = " Like libdeflate_zlib_decompress(), but adds the 'actual_in_nbytes_ret'\n argument.  If 'actual_in_nbytes_ret' is not NULL and the decompression\n succeeds (indicating that the first zlib-compressed stream in the input\n buffer was decompressed), then the actual number of input bytes consumed is\n written to *actual_in_nbytes_ret."]
    pub fn libdeflate_zlib_decompress_ex(
        decompressor: *mut libdeflate_decompressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
        actual_in_nbytes_ret: *mut usize,
        actual_out_nbytes_ret: *mut usize,
    ) -> libdeflate_result;
    #[doc = " Like libdeflate_deflate_decompress(), but assumes the gzip wrapper format\n instead of raw DEFLATE.\n\n If multiple gzip-compressed members are concatenated, then only the first\n will be decompressed.  Use libdeflate_gzip_decompress_ex() if you need\n multi-member support."]
    pub fn libdeflate_gzip_decompress(
        decompressor: *mut libdeflate_decompressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
        actual_out_nbytes_ret: *mut usize,
    ) -> libdeflate_result;
    #[doc = " Like libdeflate_gzip_decompress(), but adds the 'actual_in_nbytes_ret'\n argument.  If 'actual_in_nbytes_ret' is not NULL and the decompression\n succeeds (indicating that the first gzip-compressed member in the input\n buffer was decompressed), then the actual number of input bytes consumed is\n written to *actual_in_nbytes_ret."]
    pub fn libdeflate_gzip_decompress_ex(
        decompressor: *mut libdeflate_decompressor,
        in_: *const ::core::ffi::c_void,
        in_nbytes: usize,
        out: *mut ::core::ffi::c_void,
        out_nbytes_avail: usize,
        actual_in_nbytes_ret: *mut usize,
        actual_out_nbytes_ret: *mut usize,
    ) -> libdeflate_result;
    #[doc = " libdeflate_free_decompressor() frees a decompressor that was allocated with\n libdeflate_alloc_decompressor().  If a NULL pointer is passed in, no action\n is taken."]
    pub fn libdeflate_free_decompressor(decompressor: *mut libdeflate_decompressor);
    #[doc = " libdeflate_adler32() updates a running Adler-32 checksum with 'len' bytes of\n data and returns the updated checksum.  When starting a new checksum, the\n required initial value for 'adler' is 1.  This value is also returned when\n 'buffer' is specified as NULL."]
    pub fn libdeflate_adler32(adler: u32, buffer: *const ::core::ffi::c_void, len: usize) -> u32;
    #[doc = " libdeflate_crc32() updates a running CRC-32 checksum with 'len' bytes of data\n and returns the updated checksum.  When starting a new checksum, the required\n initial value for 'crc' is 0.  This value is also returned when 'buffer' is\n specified as NULL."]
    pub fn libdeflate_crc32(crc: u32, buffer: *const ::core::ffi::c_void, len: usize) -> u32;
    #[doc = " Install a custom memory allocator which libdeflate will use for all memory\n allocations by default.  'malloc_func' is a function that must behave like\n malloc(), and 'free_func' is a function that must behave like free().\n\n The per-(de)compressor custom memory allocator that can be specified in\n 'struct libdeflate_options' takes priority over this.\n\n This doesn't affect the free() function that will be used to free\n (de)compressors that were already in existence when this is called."]
    pub fn libdeflate_set_memory_allocator(
        malloc_func: ::core::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::core::ffi::c_void,
        >,
        free_func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    );
}
